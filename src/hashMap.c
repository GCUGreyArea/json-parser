/**
 * @file hashMap.c
 * @author Barry Robinson (barry.w.robinson64@gmail.com)
 * @brief Implimentation of hash map function
 * @version 0.1
 * @date 2021-08-31
 *
 * @copyright Copyright (c) 2021
 */

#include <stdio.h>
#include <stdlib.h>

#include "utils.h"
#include "internal.h"
#include "hashMap.h"

struct hashNode_s {
    uint32_t hashKey;           // !< The raw key of this item as geerated by the key function
    size_t place;               // !< The place this item ocupies in the table
    void * data;                // !< The data item. If delete_data_CB is define, map will delet data on remove
    struct hashNode_s * next;   // !< The next node in the even of a key collision. Note that hashKey is the raw key generated by generat_key_CB
};

struct hashBaseNode_s {
    hashNode_t * head;          // !< First availible node. NULL if node unocupied
    hashNode_t * tail;          // !< Last not in the list. Also NY+ULL if node unocupied
    int ocupancy;                // !< Number of items places in the node
};

struct hashTable_s {
    char name[MAX_HASH_TBL_NAME];
    hashBaseNode_t * table;     // !< The has sparse array of nodes
    size_t size;                // !< Szie of the table. Used to access the table
    size_t items;             // !< Number of items places in teh table
    generat_key_CB * keyCB;     // !< Callback to geenerate a key when adding
    match_data_CB  * matchCB;   // !< Callback to match a data item when a collision ocurs
    delete_data_CB * deleteCB;  // !< Callback to delete data items on remove or map teardown
    print_data_CB  * printCB;   // !< Callback to print data items in the map
    bool deleteOnRemove;        // !< Flag to allow or disalow deletion of data on remvoe

};

struct hashMap_iterator_s {
    hashMap_t * map;
    size_t lastPlace;
    hashNode_t * lastNode;
    // int lastNodeIdx;
};

/**
 * @brief Make a hash map
 *
 * @param init  Structure to initialize teh hash map with
 * @return hashTable_t* A valid hash map structure.
 */

hashMap_t * hashMap_make(hashMapInit_t * init) {
    if(init == NULL) {
        fprintf(stderr, "ERROR: Initialization structure cannot be NULL\n");
        return NULL;
    }
    else if(init->keyCB == NULL) {
        fprintf(stderr, "ERROR: Key generation callback has to be defined\n");
        return NULL;
    }
    else if(init->matchCB == NULL) {
        fprintf(stderr, "ERROR: data match callback has to be defined\n");
        return NULL;
    }

    size_t hashSize=0;
    if(!power_of_two(init->hashSize)) {
        hashSize = force_power_of_two(init->hashSize);
        fprintf(stderr,"WARNING: %ld is not a power of 2 number. Alligning to %ld\n", init->hashSize,hashSize);
    }
    else {
        hashSize = init->hashSize;
    }

    hashMap_t * tbl = (hashMap_t *) alloc_mem(sizeof(hashMap_t));
    if(tbl == NULL) {
        return NULL;
    }

    tbl->table = (hashBaseNode_t*) alloc_mem(sizeof(hashBaseNode_t) * hashSize);
    if(tbl->table == NULL) {
        free(tbl);
        return NULL;
    }

    // Set up the map name
    strcpy(tbl->name,init->name);

    // Set up the nodes
    for(size_t i=0;i<hashSize;i++) {
        tbl->table[i].head = NULL;
        tbl->table[1].tail = NULL;
        tbl->table[i].ocupancy = 0;
    }


    tbl->size     = hashSize;
    tbl->items  = 0;
    tbl->keyCB    = init->keyCB;
    tbl->deleteCB = init->deleteCB;
    tbl->matchCB  = init->matchCB;
    tbl->printCB  = init->printCB;

    // Default to true
    tbl->deleteOnRemove = true;

    return tbl;
}

/**
 * @brief Helper function to delete all data from a node
 *
 * @param node Node from the map
 * @note If there are collisions, the function will iterate
 *       through the list and delete subtended data items.
 * @param cb delete callback to use on data.
 */
inline static void hashMap_removeAllData(hashBaseNode_t * node, delete_data_CB * cb) {
    if(node == NULL) return;

    struct hashNode_s * head = node->head;
    struct hashNode_s * last = head;
    while(head) {
        if(cb) {cb(head->data);}
        head->data = NULL;
        last = head;
        head = head->next;
        free(last);
    }
}


/**
 * @brief Return all the memory from the hash map and remove all items in the map
 * @note the delete callback for each item will be called if it has been defiend.
 *
 * @param map the map to delete
 */
void hashMap_teardown(hashMap_t * map) {
    if(map == NULL) {
        return;
    }

    // Delete all the the nodes and if the callback is defined, the data
    for(size_t i=0;i<map->size;i++) {
        hashMap_removeAllData(&map->table[i],map->deleteCB);
    }

    // Free the map
    free(map->table);
    free(map);
}

/**
 * @brief Get the size of the map in availible primary nodes
 *
 * @param map
 * @return size_t nuber of availible slots in the map
 */
size_t hashMap_getSize(hashMap_t * map) {
    if(map) {
        return map->size;
    }

    return HASH_MAPP_ERR;
}

/**
 * @brief Get the number of items ocupying the hash map
 *
 * @param map
 * @return size_t Ocupation of the map or HASH_MAPP_ERR
 */

size_t hashMap_getOcupancy(hashMap_t * map) {
    if(map) {
        return map->items;
    }

    return HASH_MAPP_ERR;

}

/**
 * @brief Get the hash map name.
 * @note This is in place to facilitate mapping of maps
 *
 * @param map
 * @return const char*
 */
const char * hashMap_name(hashMap_t * map) {
    if(map) {
        return (const char *) map->name;
    }

    return NULL;

}

size_t hashMap_putDataWithKey(hashMap_t * map, void * data, void * keyData) {
    if(map == NULL) {
        fprintf(stderr,"ERROR: map cannot be NULL\n");
        return HASH_MAPP_ERR;
    }

    if(data == NULL) {
        fprintf(stderr,"ERROR: data cannot be NULL\n");
        return HASH_MAPP_ERR;
    }

    uint64_t key =  map->keyCB(keyData);
    size_t place = key & (map->size-1);

    if(map->table[place].head == NULL) {
        map->table[place].head = (hashNode_t*) alloc_mem(sizeof(hashNode_t));
        if(map->table[place].head == NULL) {
            return HASH_MAPP_ERR;
        }

        map->table[place].head->next = NULL;

        map->table[place].tail = map->table[place].head;
        map->table[place].head->hashKey = key;
        map->table[place].head->data    = data;
    }
    else {
        hashNode_t * node =(hashNode_t*) alloc_mem(sizeof(hashNode_t));
        if(node == NULL) {
            return HASH_MAPP_ERR;
        }

        node->hashKey = key;
        node->data    = data;
        map->table[place].tail->next = node;
        map->table[place].tail = node;
        node->next = NULL;
    }

    map->table[place].ocupancy++;
    map->items++;

    return place;
}



/**
 * @brief Put a data item into the map and use the data as the key
 *
 * @param map
 * @param data
 * @return size_t Index of the item in the map
 */

size_t hashMap_putWithKeyAsData(hashMap_t * map, void * data) {
    if(map == NULL) {
        fprintf(stderr,"ERROR: map cannot be NULL\n");
        return HASH_MAPP_ERR;
    }

    if(data == NULL) {
        fprintf(stderr,"ERROR: data cannot be NULL\n");
        return HASH_MAPP_ERR;
    }

    uint64_t key =  map->keyCB(data);
    size_t place = key & (map->size-1);

    if(map->table[place].head == NULL) {
        map->table[place].head = (hashNode_t*) alloc_mem(sizeof(hashNode_t));
        if(map->table[place].head == NULL) {
            return HASH_MAPP_ERR;
        }

        map->table[place].head->next = NULL;

        map->table[place].tail = map->table[place].head;
        map->table[place].head->hashKey = key;
        map->table[place].head->data    = data;
    }
    else {
        hashNode_t * node =(hashNode_t*) alloc_mem(sizeof(hashNode_t));
        if(node == NULL) {
            return HASH_MAPP_ERR;
        }

        node->hashKey = key;
        node->data    = data;
        map->table[place].tail->next = node;
        map->table[place].tail = node;
    }

    map->table[place].ocupancy++;
    map->items++;

    return place;
}

inline static void hashMap_debugNode(hashBaseNode_t * node, size_t place, print_data_CB * printCB) {
    if(node == NULL) {
        fprintf(stderr,"ERROR: map node is NULL\n");
        return;
    }

    fprintf(stdout,"Hash node [place %ld / ocupancy %d] ", place, node->ocupancy);
    if(printCB) {
        hashNode_t* dataNode = node->head;
        while(dataNode) {
            printCB(dataNode->data);
            dataNode = dataNode->next;
            if(dataNode) {fprintf(stdout,",");}
        }
    }

    fprintf(stdout,"\n");
}

/**
 * @brief Print out stats oubout the hash map for debugginh
 *
 * @param map
 */
void hashMap_debug(hashMap_t * map) {
    if(map == NULL) {
        fprintf(stderr,"ERROR: map cannot be NULL\n");
        return;
    }

    fprintf(stdout,"Hash map [name %s / size %ld / items %ld]\n", map->name,map->size,map->items);

    for(size_t i=0;i<map->size;i++) {
        if(map->table[i].ocupancy) {
            hashMap_debugNode(&map->table[i],i,map->printCB);
        }
    }
}

/**
 * @brief Provided as a basic hashing functions for strings
 *
 * @param s
 * @return uint64_t
 */
uint32_t hashMap_hashString32(const char * s) {
    uint32_t hash = 0;

    for(; *s; ++s) {
        hash += *s;
        hash += (hash << 10);
        hash ^= (hash >> 6);
    }

    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    return hash;
}

inline static void * hashMap_getMapNodeData(hashNode_t * node, void * keyData, match_data_CB * matchCB) {
    while(node) {
        if(matchCB(node->data,keyData)) {
            return node->data;
        }
        node = node->next;
    }

    return NULL;
}

/**
 * @brief Get a data item from a specified node in the map
 *
 * @param map
 * @param place The place in the map to index.
 * @param keyDaya The key data used to put the data item into the map. This is used for matching if there is a collision.
 * @return void* The data item found in the map, or NULL if not found, or an error ocurs.
 */

void * hashMap_getWithPlace(hashMap_t * map, size_t place,void * keyData) {
    if(map == NULL) {
        return NULL;
    }

    if(place > map->size) {
        fprintf(stderr,"ERROR: Place cannot be larger than map. Are you sure this place is for this map\n");
        fprintf(stderr,"ERROR: [map %s / place %ld  / items %ld]", map->name,place,map->items);
        return NULL;
    }

    return hashMap_getMapNodeData(map->table[place].head,keyData,map->matchCB);
}

void * hashMap_getWithKey(hashMap_t * map, void * keyData) {
    if(map == NULL) {
        return NULL;
    }

    uint32_t key = map->keyCB(keyData);
    size_t place = key & (map->size-1);


    return hashMap_getMapNodeData(map->table[place].head,keyData,map->matchCB);
}


bool hashMap_removeWithKey(hashMap_t * map, void * keyData) {
    uint32_t key = map->keyCB(keyData);
    size_t place = key & (map->size-1);

    return hashMap_removeWithPlace(map,place,keyData);
}


bool hashMap_removeWithPlace(hashMap_t * map, size_t place,void * keyData) {
    bool ret = false;
    if(map == NULL) {
        return ret;
    }

    if(place > map->size) {
        fprintf(stderr,"ERROR: Place cannot be larger than map. Are you sure this place is for this map\n");
        fprintf(stderr,"ERROR: [map %s / place %ld  / items %ld]", map->name,place,map->items);
        return ret;
    }

    if(map->table[place].ocupancy == 0) {
        return ret;
    }

    hashNode_t * node = map->table[place].head;
    hashNode_t * prev = node;

    while(node) {
        if(map->matchCB(node->data,keyData)) {
            if(map->deleteCB && map->deleteOnRemove) {
                map->deleteCB(node->data);
            }

            if(node == map->table[place].head) {
                if(map->table[place].ocupancy == 1) {
                    free(map->table[place].head);
                    map->table[place].head = NULL;
                    map->table[place].tail = NULL;
                }
                else {
                    free(node);
                    map->table[place].head = node->next;
                }
            }
            else if(node != map->table[place].head) {
                if(node == map->table[place].tail) {
                    free(node);
                    map->table[place].tail = prev;
                }
            }
            else {
                prev->next = node->next;
                free(node);
            }

            map->table[place].ocupancy--;
            map->items--;
            ret = true;
            break;
        }

        // Test the next node
        prev = node;
        node = node->next;
    }

    return ret;
}

/**
 * @brief Fill out an iterator with valid hash map values for this hashMap.
 *
 * @param map
 * @param it
 * @return hashMap_iterator_t*
 */
hashMap_iterator_t * hashMap_getItterator(hashMap_t * map) {
    hashMap_iterator_t * it = alloc_mem(sizeof(hashMap_iterator_t));
    if(it) {
        it->map = map;
        it->lastPlace = 0;
        it->lastNode = NULL;
    }

    return it;
}
/**
 * @brief Delete the itterator
 *
 * @param it
 */
void hashMap_deletItterator(hashMap_iterator_t * it) {
    if(it) {
        free(it);
    }
}

void * hashMap_Itterate(hashMap_iterator_t * it) {
    void * data = NULL;

    // There are no more nodes..
    if(it->lastPlace == it->map->size) {
        it->lastNode = NULL;
        // it->lastNodeIdx = 0;
        it->lastPlace = 0;
        return NULL;
    }

    // Node from the last iteration
    if(it->lastNode) {
        data = it->lastNode->data;
        it->lastNode = it->lastNode->next;
    }
    else {
        while(it->lastPlace < it->map->size && it->map->table[it->lastPlace].head == NULL) {
            it->lastPlace++;
        }

        if(it->lastPlace < it->map->size) {
            data = it->map->table[it->lastPlace].head->data;
            it->lastNode = it->map->table[it->lastPlace].head->next;
            if(it->lastNode == NULL) {
                it->lastPlace++;
            }
        }
    }

    return data;
}

void hashMap_setDeleteOnRemove(hashMap_t * map, bool val) {
    if(map) {
        map->deleteOnRemove = val;
    }
}

/**
 * @brief Calculate a metric for hash map ocupancy
 *
 * @param map
 * @return float
 */
float hashMap_calculateOcupancyMetric(hashMap_t * map) {
    if(map == NULL) {
        return HASH_MAPP_ERR;
    }

    size_t nodeOcupancy=0;
    for(size_t i=0;i<map->size;i++) {
        if(map->table[i].ocupancy > 0) {nodeOcupancy++;}
    }

    // fprintf(stdout, "Node ocupancy : %ld\n", nodeOcupancy);
    float res = (((float)nodeOcupancy / (float) map->items)) * 100;

    return res;
}

void hashMap_printStats(hashMap_t *map) {
    if(map == NULL) {
        return;
    }

    debug(LEVEL_INFO,"HasnMap [name %s / occupancy %0.2f%% / items %ld]\n",map->name,hashMap_calculateOcupancyMetric(map),map->items);
}

/**
 * @}
 * @}
 */
